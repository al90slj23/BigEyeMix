# WaveSurfer.js v7 波形编辑器开发经验

BigEyeMix 麻瓜模式波形编辑器开发过程中遇到的问题和解决方案。

## 核心概念

### 术语定义

| 中文名称 | 英文名称 | 说明 |
|---------|---------|------|
| 主波形 | Main Waveform | 上方可缩放的波形详情视图，带标尺卡 |
| 导航条 | Navigator | 下方完整音频缩略图，带视口框显示当前视图范围 |
| 标尺卡 | Ruler | 主波形上的播放位置指示器，可拖动定位 |
| 视口框 | Viewport | 导航条上的矩形框，显示主波形当前显示的音频范围 |
| 导航光标 | Navigator Cursor | 导航条上的播放位置指示线 |

### WaveSurfer v7 关键配置

```javascript
const wavesurfer = WaveSurfer.create({
    container: waveformEl,
    waveColor: track.color.light,
    progressColor: track.color.light,  // 与 waveColor 相同，禁用内置进度颜色
    cursorColor: 'transparent',        // 隐藏内置光标，使用自定义标尺
    height: 60,
    barWidth: 2,
    barGap: 1,
    barRadius: 2,
    normalize: true,
    interact: false,      // 禁用内置交互，使用自定义标尺拖动
    fillParent: true,     // 初始填满容器
    minPxPerSec: 1
});
```

## 问题与解决方案

### 问题1: 波形初始不填满容器

**现象**: 使用 `fillParent: false` 时，波形宽度由 `minPxPerSec * duration` 决定，导致短音频波形很窄，长音频波形超宽。

**解决方案**: 
1. 设置 `fillParent: true` 让波形初始填满容器
2. 在 `ready` 事件中计算 `baseZoom`（基础缩放值）
3. 缩放时基于 `baseZoom` 计算实际 zoom 值

```javascript
let baseZoom = 1;
let currentZoom = 1;  // 缩放倍数 (1 = 显示全部)

wavesurfer.once('ready', () => {
    const duration = wavesurfer.getDuration();
    const containerWidth = waveformContainer.clientWidth - 20;
    if (duration > 0 && containerWidth > 0) {
        baseZoom = containerWidth / duration;  // 每秒像素数
        wavesurfer.zoom(baseZoom);
    }
});

const applyZoom = (newMultiplier) => {
    currentZoom = Math.max(1, Math.min(50, newMultiplier));
    wavesurfer.zoom(baseZoom * currentZoom);
};
```

### 问题2: 标尺位置与 WaveSurfer 进度不同步

**现象**: WaveSurfer 内置的 `progressColor` 分界线与自定义标尺位置不一致。

**原因**: 
- 标尺位置是相对于可视区域计算的 (`visibleX = absoluteX - scrollLeft`)
- WaveSurfer 的 progress 是相对于整个波形的绝对位置
- 当波形滚动时，两者参考系不同

**解决方案**: 禁用 WaveSurfer 的 progressColor，只使用自定义标尺

```javascript
progressColor: track.color.light,  // 与 waveColor 相同，视觉上无进度区分
```

### 问题3: 标尺被 overflow:hidden 裁剪

**现象**: 标尺设置了 `top: -16px; bottom: -16px` 想要超出容器显示，但被父元素裁剪。

**解决方案**: 
1. CSS: 父元素 `.waveform-main` 设置 `overflow: visible`
2. JS: 限制标尺位置在合理范围内，防止完全不可见

```css
.waveform-main {
    position: relative;
    overflow: visible;  /* 允许标尺超出显示 */
}
```

```javascript
// 限制标尺在可见区域内
const minX = -12;  // handle 半径
const maxX = containerWidth + 12;
visibleX = Math.max(minX, Math.min(maxX, visibleX));
```

### 问题4: 获取正确的滚动容器

**现象**: 使用 `fillParent: false` 时，`waveformContainer.scrollWidth` 返回的值不正确。

**原因**: WaveSurfer v7 在 `fillParent: false` 模式下会创建自己的内部 `scrollContainer`。

**解决方案**: 使用 `wavesurfer.renderer.scrollContainer` 获取正确的滚动容器

```javascript
const scrollContainer = wavesurfer?.renderer?.scrollContainer;
if (!scrollContainer) return;

const scrollWidth = scrollContainer.scrollWidth;
const clientWidth = scrollContainer.clientWidth;
const scrollLeft = scrollContainer.scrollLeft;
```

### 问题5: 滚动事件监听

**现象**: 监听 `waveformContainer.addEventListener('scroll')` 无法捕获滚动事件。

**原因**: 实际滚动发生在 WaveSurfer 内部的 scrollContainer 上。

**解决方案**: 使用 WaveSurfer 的 `scroll` 事件

```javascript
wavesurfer.on('scroll', () => {
    updateScrollEdges();
    updateViewport();
    updateRulerPosition(progress, false);
});
```

## 标尺位置计算

```javascript
const updateRulerPosition = (progress, autoScroll = false) => {
    const scrollContainer = wavesurfer?.renderer?.scrollContainer;
    if (!scrollContainer) return;
    
    const scrollWidth = scrollContainer.scrollWidth;
    const containerWidth = scrollContainer.clientWidth;
    const scrollLeft = scrollContainer.scrollLeft;
    
    // 标尺在整个波形中的绝对位置
    const absoluteX = progress * scrollWidth;
    // 相对于可视区域的位置
    let visibleX = absoluteX - scrollLeft;
    
    // 限制在可见范围
    visibleX = Math.max(-12, Math.min(containerWidth + 12, visibleX));
    rulerEl.style.left = visibleX + 'px';
    
    // 播放时自动滚动
    if (autoScroll && isPlaying && currentZoom > 1) {
        const threshold = containerWidth * 0.6;
        if (visibleX > threshold) {
            const newScrollLeft = absoluteX - containerWidth / 2;
            scrollContainer.scrollLeft = Math.min(newScrollLeft, scrollWidth - containerWidth);
        }
    }
};
```

## 导航条视口框计算

```javascript
const updateViewport = () => {
    const scrollContainer = wavesurfer?.renderer?.scrollContainer;
    if (!scrollContainer) return;
    
    const scrollWidth = scrollContainer.scrollWidth;
    const containerWidth = scrollContainer.clientWidth;
    const scrollLeft = scrollContainer.scrollLeft;
    
    // 视口宽度百分比（未放大时为100%）
    const viewportWidthPercent = (containerWidth / scrollWidth) * 100;
    // 视口左边位置百分比
    const viewportLeftPercent = (scrollLeft / scrollWidth) * 100;
    
    navigatorViewport.style.width = viewportWidthPercent + '%';
    navigatorViewport.style.left = viewportLeftPercent + '%';
};
```

## 调试技巧

### 使用 Chrome DevTools MCP 自动化测试

```javascript
// 自动加载历史文件并进入第二步
async () => {
    const files = [
        { fileId: "xxx", filename: "file1.mp3", size: 1234 },
        { fileId: "yyy", filename: "file2.flac", size: 5678 }
    ];
    
    for (let i = 0; i < 2; i++) {
        currentHistoryIndex = i;
        await selectHistoryFile(files[i].fileId, files[i].filename, files[i].size);
    }
    
    nextStep();
}
```

### 检查 WaveSurfer 内部状态

```javascript
() => {
    const ws = state.tracks[0]?.wavesurfer;
    const sc = ws?.renderer?.scrollContainer;
    return {
        duration: ws?.getDuration(),
        currentTime: ws?.getCurrentTime(),
        scrollWidth: sc?.scrollWidth,
        clientWidth: sc?.clientWidth,
        scrollLeft: sc?.scrollLeft
    };
}
```

## 相关文件

- `web/muggle/Muggle.editor.js` - 波形编辑器主逻辑
- `web/muggle/Muggle.editor.css` - 标尺、导航条样式
- `web/muggle/index.mobile.html` - 页面入口
